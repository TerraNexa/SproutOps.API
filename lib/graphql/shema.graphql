# GraphQL schema for SproutOps single-table design

# Enums for fixed values

enum PricingType {
  "Hourly pricing"
  HOURLY
  "Flat fee pricing"
  FLAT
}

enum JobStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
}

enum InvoiceStatus {
  DRAFT
  ISSUED
  PAID
  OVERDUE
}

enum ProposalStatus {
  DRAFT
  SENT
  ACCEPTED
  DECLINED
}

enum RecurringJobStatus {
  ACTIVE
  PAUSED
  CANCELLED
}

enum EquipmentStatus {
  AVAILABLE
  IN_USE
  MAINTENANCE
}

enum InventoryTxnType {
  PURCHASE
  CONSUMPTION
}

enum NotificationLevel {
  INFO
  WARN
  ERROR
}

enum NotificationChannel {
  EMAIL
  SMS
}

# Enums for sorting

enum SortDirection {
  ASC
  DESC
}
enum BusinessSortField {
  BUSINESS_ID
  NAME
  ADDRESS
  CREATED_AT
  UPDATED_AT
}
enum UserSortField {
  USER_ID
  NAME
  EMAIL
  ROLE
  CREATED_AT
  UPDATED_AT
}
enum CustomerSortField {
  CUSTOMER_ID
  NAME
  EMAIL
  CREATED_AT
  UPDATED_AT
}
enum ServiceSortField {
  SERVICE_ID
  NAME
  CREATED_AT
  UPDATED_AT
}
enum JobSortField {
  JOB_ID
  CUSTOMER_ID
  SCHEDULED_START_AT
  SCHEDULED_END_AT
  CREATED_AT
  UPDATED_AT
  STATUS
}
enum CrewSortField {
  CREW_ID
  NAME
  CREATED_AT
  UPDATED_AT
}
enum EquipmentSortField {
  EQUIPMENT_ID
  STATUS
  CREATED_AT
  UPDATED_AT
}
enum InvoiceSortField {
  INVOICE_ID
  CUSTOMER_ID
  ISSUED_AT
  DUE_DATE
  CREATED_AT
  UPDATED_AT
  STATUS
}
enum PaymentSortField {
  PAYMENT_ID
  CUSTOMER_ID
  PAID_AT
  CREATED_AT
  UPDATED_AT
}
enum ProposalSortField {
  PROPOSAL_ID
  CUSTOMER_ID
  CREATED_AT
  VALID_UNTIL
  STATUS
}
enum RecurringJobSortField {
  RECURRING_ID
  CUSTOMER_ID
  NEXT_RUN_AT
  CREATED_AT
  UPDATED_AT
  STATUS
}
enum TimeEntrySortField {
  TIME_ENTRY_ID
  USER_ID
  JOB_ID
  START_AT
  CREATED_AT
}
enum MaterialSortField {
  MATERIAL_ID
  NAME
  CURRENT_STOCK
  CREATED_AT
  UPDATED_AT
}
enum InventoryTransactionSortField {
  TXN_ID
  MATERIAL_ID
  CREATED_AT
}
enum MaintenanceRecordSortField {
  MAINTENANCE_ID
  EQUIPMENT_ID
  SERVICE_DATE
}
enum SupplierSortField {
  SUPPLIER_ID
  NAME
  CREATED_AT
  UPDATED_AT
}
enum NotificationSortField {
  NOTIFICATION_ID
  CREATED_AT
  READ
}
enum ExpenseSortField {
  EXPENSE_ID
  DATE
  AMOUNT
}

# Comparison filter inputs
input IDFilter {
  eq: ID
  ne: ID
  in: [ID!]
  nin: [ID!]
}
input StringFilter {
  eq: String
  ne: String
  contains: String
  startsWith: String
  in: [String!]
  nin: [String!]
}
input DateTimeFilter {
  eq: AWSDateTime
  ne: AWSDateTime
  lt: AWSDateTime
  lte: AWSDateTime
  gt: AWSDateTime
  gte: AWSDateTime
}
input DateFilter {
  eq: AWSDate
  ne: AWSDate
  lt: AWSDate
  lte: AWSDate
  gt: AWSDate
  gte: AWSDate
}
input IntFilter {
  eq: Int
  ne: Int
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  in: [Int!]
  nin: [Int!]
}
input FloatFilter {
  eq: Float
  ne: Float
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  in: [Float!]
  nin: [Float!]
}

# "Where" inputs per entity
input BusinessWhereInput {
  businessId: IDFilter
  name: StringFilter
  address: StringFilter
}
input UserWhereInput {
  userId: IDFilter
  businessId: IDFilter
  role: StringFilter
}
input CustomerWhereInput {
  customerId: IDFilter
  businessId: IDFilter
}
input ServiceWhereInput {
  serviceId: IDFilter
  businessId: IDFilter
}
input JobWhereInput {
  jobId: IDFilter
  businessId: IDFilter
  customerId: IDFilter
  status: JobStatus
}
input CrewWhereInput {
  crewId: IDFilter
  businessId: IDFilter
}
input EquipmentWhereInput {
  equipmentId: IDFilter
  businessId: IDFilter
  status: EquipmentStatus
}
input InvoiceWhereInput {
  invoiceId: IDFilter
  businessId: IDFilter
  customerId: IDFilter
  status: InvoiceStatus
}
input PaymentWhereInput {
  paymentId: IDFilter
  customerId: IDFilter
  invoiceId: IDFilter
}
input ProposalWhereInput {
  proposalId: IDFilter
  customerId: IDFilter
  status: ProposalStatus
}
input RecurringJobWhereInput {
  recurringId: IDFilter
  customerId: IDFilter
  status: RecurringJobStatus
}
input TimeEntryWhereInput {
  timeEntryId: IDFilter
  businessId: IDFilter
  userId: IDFilter
  jobId: IDFilter
  crewId: IDFilter
}
input MaterialWhereInput {
  materialId: IDFilter
  businessId: IDFilter
}
input InventoryTransactionWhereInput {
  txnId: IDFilter
  materialId: IDFilter
  type: InventoryTxnType
}
input MaintenanceRecordWhereInput {
  maintenanceId: IDFilter
  equipmentId: IDFilter
}
input SupplierWhereInput {
  supplierId: IDFilter
  businessId: IDFilter
}
input NotificationWhereInput {
  notificationId: IDFilter
  userId: IDFilter
  level: NotificationLevel
  read: Boolean
}
input ExpenseWhereInput {
  expenseId: IDFilter
  businessId: IDFilter
  category: StringFilter
}

# Pagination
input PaginationInput {
  limit: Int
  nextToken: String
}

# Sorting inputs per entity
input BusinessSortInput {
  field: BusinessSortField!
  direction: SortDirection!
}
input UserSortInput {
  field: UserSortField!
  direction: SortDirection!
}
input CustomerSortInput {
  field: CustomerSortField!
  direction: SortDirection!
}
input ServiceSortInput {
  field: ServiceSortField!
  direction: SortDirection!
}
input JobSortInput {
  field: JobSortField!
  direction: SortDirection!
}
input CrewSortInput {
  field: CrewSortField!
  direction: SortDirection!
}
input EquipmentSortInput {
  field: EquipmentSortField!
  direction: SortDirection!
}
input InvoiceSortInput {
  field: InvoiceSortField!
  direction: SortDirection!
}
input PaymentSortInput {
  field: PaymentSortField!
  direction: SortDirection!
}
input ProposalSortInput {
  field: ProposalSortField!
  direction: SortDirection!
}
input RecurringJobSortInput {
  field: RecurringJobSortField!
  direction: SortDirection!
}
input TimeEntrySortInput {
  field: TimeEntrySortField!
  direction: SortDirection!
}
input MaterialSortInput {
  field: MaterialSortField!
  direction: SortDirection!
}
input InventoryTransactionSortInput {
  field: InventoryTransactionSortField!
  direction: SortDirection!
}
input MaintenanceRecordSortInput {
  field: MaintenanceRecordSortField!
  direction: SortDirection!
}
input SupplierSortInput {
  field: SupplierSortField!
  direction: SortDirection!
}
input NotificationSortInput {
  field: NotificationSortField!
  direction: SortDirection!
}
input ExpenseSortInput {
  field: ExpenseSortField!
  direction: SortDirection!
}

# List inputs combining where, sort, and pagination
input BusinessListInput {
  where: BusinessWhereInput
  sortBy: BusinessSortInput
  pagination: PaginationInput
}
input UserListInput {
  where: UserWhereInput
  sortBy: UserSortInput
  pagination: PaginationInput
}
input CustomerListInput {
  where: CustomerWhereInput
  sortBy: CustomerSortInput
  pagination: PaginationInput
}
input ServiceListInput {
  where: ServiceWhereInput
  sortBy: ServiceSortInput
  pagination: PaginationInput
}
input JobListInput {
  where: JobWhereInput
  sortBy: JobSortInput
  pagination: PaginationInput
}
input CrewListInput {
  where: CrewWhereInput
  sortBy: CrewSortInput
  pagination: PaginationInput
}
input EquipmentListInput {
  where: EquipmentWhereInput
  sortBy: EquipmentSortInput
  pagination: PaginationInput
}
input InvoiceListInput {
  where: InvoiceWhereInput
  sortBy: InvoiceSortInput
  pagination: PaginationInput
}
input PaymentListInput {
  where: PaymentWhereInput
  sortBy: PaymentSortInput
  pagination: PaginationInput
}
input ProposalListInput {
  where: ProposalWhereInput
  sortBy: ProposalSortInput
  pagination: PaginationInput
}
input RecurringJobListInput {
  where: RecurringJobWhereInput
  sortBy: RecurringJobSortInput
  pagination: PaginationInput
}
input TimeEntryListInput {
  where: TimeEntryWhereInput
  sortBy: TimeEntrySortInput
  pagination: PaginationInput
}
input MaterialListInput {
  where: MaterialWhereInput
  sortBy: MaterialSortInput
  pagination: PaginationInput
}
input InventoryTransactionListInput {
  where: InventoryTransactionWhereInput
  sortBy: InventoryTransactionSortInput
  pagination: PaginationInput
}
input MaintenanceRecordListInput {
  where: MaintenanceRecordWhereInput
  sortBy: MaintenanceRecordSortInput
  pagination: PaginationInput
}
input SupplierListInput {
  where: SupplierWhereInput
  sortBy: SupplierSortInput
  pagination: PaginationInput
}
input NotificationListInput {
  where: NotificationWhereInput
  sortBy: NotificationSortInput
  pagination: PaginationInput
}
input ExpenseListInput {
  where: ExpenseWhereInput
  sortBy: ExpenseSortInput
  pagination: PaginationInput
}

# Object Types

type User {
  userId: ID!
  name: String!
  email: String!
  role: String!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  # Connected entities
  businesses: [Business!]!
  timeEntries: [TimeEntry!]!
}

type Business {
  businessId: ID!
  name: String!
  address: String!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  # Connected entities
  customers: [Customer!]!
  users: [User!]!
  services: [Service!]!
  jobs: [Job!]!
  crews: [Crew!]!
  equipment: [Equipment!]!
  invoices: [Invoice!]!
  proposals: [Proposal!]!
  recurringJobs: [RecurringJob!]!
  materials: [Material!]!
  suppliers: [Supplier!]!
}

"""
Represents membership of a user in a business.
"""
type Membership {
  user: User!
  business: Business!
  role: String!
  joinedAt: AWSDateTime!
}

# Customer type and connections
"""
Customer account, may join businesses.
"""
type Customer {
  customerId: ID!
  name: String!
  email: String!
  phone: String
  address: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  # Connected entities
  businesses: [Business!]!
  jobs: [Job!]!
  invoices: [Invoice!]!
  payments: [Payment!]!
  proposals: [Proposal!]!
  recurringJobs: [RecurringJob!]!
}

"""
Link customer to business membership.
"""
type CustomerMembership {
  customer: Customer!
  business: Business!
  joinedAt: AWSDateTime!
}

# Service offering and snapshot
"""
A service offered by a business.
"""
type Service {
  serviceId: ID!
  name: String!
  description: String
  pricingType: PricingType!
  pricePerHour: Float
  flatFee: Float
  estimatedDuration: Int
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

"""
Snapshot of a service at booking time.
"""
type ServiceSnapshot {
  serviceId: ID!
  serviceName: String!
  pricingType: PricingType!
  pricePerHour: Float
  flatFee: Float
  estimatedDuration: Int
  actualStartAt: AWSDateTime
  actualEndAt: AWSDateTime
  actualDuration: Int
}

# Job and related entities
"""
A scheduled job for a customer.
"""
type Job {
  jobId: ID!
  customer: Customer!
  services: [ServiceSnapshot!]!
  totalEstimatedDuration: Int!
  scheduledStartAt: AWSDateTime!
  scheduledEndAt: AWSDateTime!
  totalEstimatedCost: Float!
  actualStartAt: AWSDateTime
  actualEndAt: AWSDateTime
  totalActualDuration: Int
  status: JobStatus!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

"""
A crew or team within a business.
"""
type Crew {
  crewId: ID!
  name: String!
  members: [User!] # Users in this crew
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

"""
Equipment owned by a business.
"""
type Equipment {
  equipmentId: ID!
  name: String!
  type: String!
  status: EquipmentStatus!
  purchaseDate: AWSDate
  lastServiceAt: AWSDate
  nextServiceDue: AWSDate
  location: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

"""
Assignment of equipment to a job and crew.
"""
type EquipmentAssignment {
  equipment: Equipment!
  job: Job!
  crew: Crew!
  scheduledStart: AWSDateTime!
  scheduledEnd: AWSDateTime!
}

"""
Line item for invoices/proposals.
"""
type LineItem {
  description: String!
  quantity: Int!
  unitPrice: Float!
  totalPrice: Float!
}

# Invoicing and payments
"""
An invoice issued to a customer.
"""
type Invoice {
  invoiceId: ID!
  customer: Customer!
  status: InvoiceStatus!
  issuedAt: AWSDateTime!
  dueDate: AWSDate!
  paidAt: AWSDateTime
  lineItems: [LineItem!]!
  subTotal: Float!
  tax: Float!
  total: Float!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

"""
A payment made against an invoice.
"""
type Payment {
  paymentId: ID!
  invoice: Invoice!
  customer: Customer!
  amount: Float!
  method: String!
  provider: String
  externalPaymentId: String
  externalChargeId: String
  paidAt: AWSDateTime!
  dispatchChannels: [NotificationChannel!]
  dispatchedAt: AWSDateTime
}

# Proposals
"""
A sales proposal or estimate sent to a customer.
"""
type Proposal {
  proposalId: ID!
  customer: Customer!
  status: ProposalStatus!
  createdAt: AWSDateTime!
  validUntil: AWSDate!
  updatedAt: AWSDateTime!
  lineItems: [LineItem!]!
  subTotal: Float!
  tax: Float!
  total: Float!
}

# Recurring jobs
"""
Template for recurring jobs.
"""
type RecurringJob {
  recurringId: ID!
  name: String!
  customer: Customer!
  services: [ServiceSnapshot!]!
  recurrenceRule: String!
  leadTimeDays: Int!
  nextRunAt: AWSDateTime!
  status: RecurringJobStatus!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

# Time tracking
"""
A time entry logged by a user or crew.
"""
type TimeEntry {
  timeEntryId: ID!
  user: User!
  crew: Crew
  job: Job
  startAt: AWSDateTime!
  endAt: AWSDateTime!
  duration: Int!
  notes: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

# Inventory
"""
Material definition with stock info.
"""
type Material {
  materialId: ID!
  name: String!
  unit: String!
  unitCost: Float!
  currentStock: Int!
  reorderThreshold: Int!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

"""
Inventory transaction for material.
"""
type InventoryTransaction {
  txnId: ID!
  material: Material!
  type: InventoryTxnType!
  quantity: Int!
  relatedJob: Job
  unitCost: Float!
  supplier: Supplier
  note: String
  createdAt: AWSDateTime!
}

# Maintenance
"""
Record of maintenance or repairs.
"""
type MaintenanceRecord {
  maintenanceId: ID!
  equipment: Equipment!
  serviceDate: AWSDate!
  type: String!
  provider: String!
  notes: String
  cost: Float
  nextServiceDue: AWSDate
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

# Suppliers
"""
Supplier or vendor profile.
"""
type Supplier {
  supplierId: ID!
  name: String!
  contactName: String
  email: String
  phone: String
  address: String
  paymentTerms: String
  leadTimeDays: Int
  materials: [String!]
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

# Notifications
"""
In-app or outbound notification.
"""
type Notification {
  notificationId: ID!
  type: String!
  level: NotificationLevel!
  message: String!
  relatedEntityType: String!
  relatedEntityId: ID!
  channels: [NotificationChannel!]
  read: Boolean!
  readAt: AWSDateTime
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  dispatchedAt: AWSDateTime
}

# Expenses
"""
Expense record for a business.
"""
type Expense {
  expenseId: ID!
  date: AWSDate!
  amount: Float!
  currency: String!
  category: String!
  description: String
  job: Job
  vendor: Supplier
  receiptUrl: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

# Root Query type
"""
All read operations.
"""
type Query {
  businesses(input: BusinessListInput): [Business!]!
  users(input: UserListInput): [User!]!
  customers(input: CustomerListInput): [Customer!]!
  services(input: ServiceListInput): [Service!]!
  jobs(input: JobListInput): [Job!]!
  crews(input: CrewListInput): [Crew!]!
  equipment(input: EquipmentListInput): [Equipment!]!
  invoices(input: InvoiceListInput): [Invoice!]!
  payments(input: PaymentListInput): [Payment!]!
  proposals(input: ProposalListInput): [Proposal!]!
  recurringJobs(input: RecurringJobListInput): [RecurringJob!]!
  timeEntries(input: TimeEntryListInput): [TimeEntry!]!
  materials(input: MaterialListInput): [Material!]!
  inventoryTransactions(
    input: InventoryTransactionListInput
  ): [InventoryTransaction!]!
  maintenanceRecords(input: MaintenanceRecordListInput): [MaintenanceRecord!]!
  suppliers(input: SupplierListInput): [Supplier!]!
  notifications(input: NotificationListInput): [Notification!]!
  expenses(input: ExpenseListInput): [Expense!]!

  user(userId: ID!): User
  business(businessId: ID!): Business
  customer(customerId: ID!): Customer
  service(businessId: ID!, serviceId: ID!): Service
  job(businessId: ID!, jobId: ID!): Job
  # equipment(businessId: ID!, equipmentId: ID!): Equipment
  invoice(businessId: ID!, invoiceId: ID!): Invoice
  proposal(businessId: ID!, proposalId: ID!): Proposal
  recurringJob(businessId: ID!, recurringId: ID!): RecurringJob
  material(materialId: ID!): Material
}

# Mutation definitions for CRUD operations
"""
All create, update, and delete operations.
"""
type Mutation {
  createBusiness(input: CreateBusinessInput!): Business!
  updateBusiness(input: UpdateBusinessInput!): Business!
  deleteBusiness(businessId: ID!): Boolean!

  createUser(input: CreateUserInput!): User!
  updateUser(input: UpdateUserInput!): User!
  deleteUser(userId: ID!): Boolean!

  createCustomer(input: CreateCustomerInput!): Customer!
  updateCustomer(input: UpdateCustomerInput!): Customer!
  deleteCustomer(customerId: ID!): Boolean!
  joinCustomerToBusiness(
    input: JoinCustomerToBusinessInput!
  ): CustomerMembership!

  createService(input: CreateServiceInput!): Service!
  updateService(input: UpdateServiceInput!): Service!
  deleteService(serviceId: ID!): Boolean!

  createJob(input: CreateJobInput!): Job!
  updateJob(input: UpdateJobInput!): Job!
  deleteJob(jobId: ID!): Boolean!

  createInvoice(input: CreateInvoiceInput!): Invoice!
  updateInvoice(input: UpdateInvoiceInput!): Invoice!
  deleteInvoice(invoiceId: ID!): Boolean!

  createPayment(input: CreatePaymentInput!): Payment!
  updatePayment(input: UpdatePaymentInput!): Payment!
  deletePayment(paymentId: ID!): Boolean!

  createProposal(input: CreateProposalInput!): Proposal!
  updateProposal(input: UpdateProposalInput!): Proposal!
  deleteProposal(proposalId: ID!): Boolean!

  createRecurringJob(input: CreateRecurringJobInput!): RecurringJob!
  updateRecurringJob(input: UpdateRecurringJobInput!): RecurringJob!
  deleteRecurringJob(recurringId: ID!): Boolean!

  createTimeEntry(input: CreateTimeEntryInput!): TimeEntry!
  updateTimeEntry(input: UpdateTimeEntryInput!): TimeEntry!
  deleteTimeEntry(timeEntryId: ID!): Boolean!

  createMaterial(input: CreateMaterialInput!): Material!
  updateMaterial(input: UpdateMaterialInput!): Material!
  deleteMaterial(materialId: ID!): Boolean!

  createInventoryTransaction(
    input: CreateInventoryTransactionInput!
  ): InventoryTransaction!
  updateInventoryTransaction(
    input: UpdateInventoryTransactionInput!
  ): InventoryTransaction!
  deleteInventoryTransaction(txnId: ID!): Boolean!

  createMaintenanceRecord(
    input: CreateMaintenanceRecordInput!
  ): MaintenanceRecord!
  updateMaintenanceRecord(
    input: UpdateMaintenanceRecordInput!
  ): MaintenanceRecord!
  deleteMaintenanceRecord(maintenanceId: ID!): Boolean!

  createSupplier(input: CreateSupplierInput!): Supplier!
  updateSupplier(input: UpdateSupplierInput!): Supplier!
  deleteSupplier(supplierId: ID!): Boolean!

  createNotification(input: CreateNotificationInput!): Notification!
  markNotificationRead(notificationId: ID!): Notification!
  deleteNotification(notificationId: ID!): Boolean!

  createExpense(input: CreateExpenseInput!): Expense!
  updateExpense(input: UpdateExpenseInput!): Expense!
  deleteExpense(expenseId: ID!): Boolean!
}

# Input types for mutations
input CreateBusinessInput {
  name: String!
  address: String!
}
input UpdateBusinessInput {
  businessId: ID!
  name: String
  address: String
}
input CreateUserInput {
  name: String!
  email: String!
  role: String!
  businessId: ID!
}
input UpdateUserInput {
  userId: ID!
  name: String
  email: String
  role: String
}
input CreateCustomerInput {
  name: String!
  email: String!
  phone: String
  address: String
  businessId: ID
}
input UpdateCustomerInput {
  customerId: ID!
  name: String
  email: String
  phone: String
  address: String
}
input JoinCustomerToBusinessInput {
  customerId: ID!
  businessId: ID!
}
input CreateServiceInput {
  name: String!
  description: String
  pricingType: PricingType!
  pricePerHour: Float
  flatFee: Float
  estimatedDuration: Int
  businessId: ID!
}
input UpdateServiceInput {
  serviceId: ID!
  name: String
  description: String
  pricingType: PricingType
  pricePerHour: Float
  flatFee: Float
  estimatedDuration: Int
}
input ServiceSnapshotInput {
  serviceId: ID!
  pricePerHour: Float
  flatFee: Float
  estimatedDuration: Int
}
input CreateJobInput {
  customerId: ID!
  services: [ServiceSnapshotInput!]!
  scheduledStartAt: AWSDateTime!
  scheduledEndAt: AWSDateTime!
  totalEstimatedCost: Float!
  status: JobStatus!
  businessId: ID!
}
input UpdateJobInput {
  jobId: ID!
  services: [ServiceSnapshotInput!]
  scheduledStartAt: AWSDateTime
  scheduledEndAt: AWSDateTime
  status: JobStatus
  totalEstimatedCost: Float
}
input CreateInvoiceInput {
  customerId: ID!
  lineItems: [LineItemInput!]!
  issuedAt: AWSDateTime!
  dueDate: AWSDate!
  subTotal: Float!
  tax: Float!
  total: Float!
  status: InvoiceStatus!
  businessId: ID!
}
input UpdateInvoiceInput {
  invoiceId: ID!
  status: InvoiceStatus
  paidAt: AWSDateTime
  lineItems: [LineItemInput!]
  dueDate: AWSDate
}
input LineItemInput {
  description: String!
  quantity: Int!
  unitPrice: Float!
}
input CreatePaymentInput {
  invoiceId: ID!
  customerId: ID!
  amount: Float!
  method: String!
  provider: String
  externalPaymentId: String
  externalChargeId: String
  paidAt: AWSDateTime!
  dispatchChannels: [NotificationChannel!]
}
input UpdatePaymentInput {
  paymentId: ID!
  status: String
  amount: Float
}
input CreateProposalInput {
  customerId: ID!
  lineItems: [LineItemInput!]!
  validUntil: AWSDate!
  subTotal: Float!
  tax: Float!
  total: Float!
  status: ProposalStatus!
  businessId: ID!
}
input UpdateProposalInput {
  proposalId: ID!
  status: ProposalStatus
  validUntil: AWSDate
}
input CreateRecurringJobInput {
  name: String!
  customerId: ID!
  services: [ServiceSnapshotInput!]!
  recurrenceRule: String!
  leadTimeDays: Int!
  nextRunAt: AWSDateTime!
  status: RecurringJobStatus!
  businessId: ID!
}
input UpdateRecurringJobInput {
  recurringId: ID!
  status: RecurringJobStatus
  nextRunAt: AWSDateTime
}
input CreateTimeEntryInput {
  userId: ID!
  crewId: ID
  jobId: ID
  startAt: AWSDateTime!
  endAt: AWSDateTime!
  duration: Int!
  notes: String
}
input UpdateTimeEntryInput {
  timeEntryId: ID!
  endAt: AWSDateTime
  duration: Int
  notes: String
}
input CreateMaterialInput {
  name: String!
  unit: String!
  unitCost: Float!
  currentStock: Int!
  reorderThreshold: Int!
  businessId: ID!
}
input UpdateMaterialInput {
  materialId: ID!
  name: String
  unit: String
  unitCost: Float
  currentStock: Int
  reorderThreshold: Int
}
input CreateInventoryTransactionInput {
  materialId: ID!
  type: InventoryTxnType!
  quantity: Int!
  unitCost: Float!
  relatedJob: ID
  supplierId: ID
  note: String
}
input UpdateInventoryTransactionInput {
  txnId: ID!
  quantity: Int
  note: String
}
input CreateMaintenanceRecordInput {
  equipmentId: ID!
  serviceDate: AWSDate!
  type: String!
  provider: String!
  notes: String
  cost: Float
  nextServiceDue: AWSDate
}
input UpdateMaintenanceRecordInput {
  maintenanceId: ID!
  notes: String
  cost: Float
  nextServiceDue: AWSDate
}
input CreateSupplierInput {
  name: String!
  contactName: String
  email: String
  phone: String
  address: String
  paymentTerms: String
  leadTimeDays: Int
}
input UpdateSupplierInput {
  supplierId: ID!
  name: String
  contactName: String
  email: String
  phone: String
  address: String
  paymentTerms: String
  leadTimeDays: Int
}
input CreateNotificationInput {
  userId: ID!
  type: String!
  level: NotificationLevel!
  message: String!
  relatedEntityType: String!
  relatedEntityId: ID!
  channels: [NotificationChannel!]
}
input CreateExpenseInput {
  date: AWSDate!
  amount: Float!
  currency: String!
  category: String!
  description: String
  jobId: ID
  vendorId: ID
  receiptUrl: String
}
input UpdateExpenseInput {
  expenseId: ID!
  amount: Float
  category: String
  description: String
}

# Subscriptions for real-time updates
"""
Real-time subscription for app events.
"""
type Subscription {
  "New notification for a user"
  notificationCreated(userId: ID!): Notification!
  "Job updated within a business"
  jobUpdated(businessId: ID!): Job!
  "Invoice paid within a business"
  invoicePaid(businessId: ID!): Invoice!
}
